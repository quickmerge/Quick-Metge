<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Quick Merge – Merge, Compress & Convert Files</title>
  <!-- Required Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #0f0f10, #111215);
      color: #f0f0f0;
      line-height: 1.6;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    /* Header */
    header {
      background: rgba(15, 15, 16, 0.95);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: auto;
      padding: 1rem 2rem;
    }

    .nav h1 {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .nav .nav-links {
      display: flex;
      gap: 1.5rem;
    }

    .nav .nav-links a {
      font-size: 1rem;
      color: #ccc;
      transition: color 0.2s;
    }

    .nav .nav-links a:hover {
      color: #fff;
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 2rem;
    }

    .hero {
      text-align: center;
      padding: 5rem 2rem 3rem;
    }

    .hero h2 {
      font-size: 2.8rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .hero p {
      color: #aaa;
      margin-top: 1rem;
      font-size: 1.2rem;
    }

    .cta {
      margin-top: 2rem;
    }

    .cta button {
      background: #6c5dd3;
      color: white;
      padding: 0.8rem 1.6rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: 0.3s ease;
    }

    .cta button:hover {
      background: #5842c3;
    }

    /* Tool Cards Grid */
    .tools {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      margin-top: 4rem;
    }

    .tool-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .tool-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 0 28px rgba(108, 93, 211, 0.25);
    }

    .tool-card h3 {
      font-size: 1.3rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .tool-card p {
      color: #bbb;
      font-size: 0.95rem;
    }

    /* Tool Content */
    .tool-content {
      display: none;
      margin-top: 1.5rem;
    }

    .tool-card.active {
      padding-bottom: 2.5rem;
    }

    .tool-card.active .tool-content {
      display: block;
    }

    .file-input {
      width: 100%;
      margin-bottom: 1rem;
    }

    .file-input label {
      display: block;
      margin-bottom: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .file-input input[type="file"] {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      display: none;
    }

    .drag-drop-area {
      width: 100%;
      padding: 2rem;
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 1rem;
    }

    .drag-drop-area:hover {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.1);
    }

    .drag-drop-area.active {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.2);
    }

    .drag-drop-area p {
      margin-bottom: 0.5rem;
    }

    .drag-drop-area .small {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-list {
      margin-top: 1rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .file-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }

    .file-item-size {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-item-remove {
      color: #ff6b6b;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    .tool-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-top: 0.5rem;
      width: 100%;
    }

    .tool-btn:hover {
      background: #5842c3;
    }

    .tool-btn.secondary {
      background: transparent;
      border: 1px solid #6c5dd3;
      margin-top: 0.5rem;
    }

    .tool-btn.secondary:hover {
      background: rgba(108, 93, 211, 0.1);
    }

    .tool-btn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .options {
      margin: 1rem 0;
    }

    .option-group {
      margin-bottom: 1rem;
    }

    .option-group label {
      display: block;
      margin-bottom: 0.3rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .option-group input[type="text"],
    .option-group input[type="number"],
    .option-group select {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
    }

    .option-group input[type="range"] {
      width: 100%;
    }

    .preview-container {
      margin-top: 1rem;
      text-align: center;
    }

    .preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 6px;
    }

    .qr-code-container {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }

    /* Status messages */
    .status-message {
      margin-top: 1rem;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      text-align: center;
    }

    .status-message.success {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
    }

    .status-message.error {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
    }

    /* Privacy */
    .privacy {
      text-align: center;
      margin-top: 5rem;
    }

    .privacy h2 {
      font-size: 2rem;
      color: #fff;
    }

    .privacy p {
      margin-top: 1rem;
      color: #aaa;
    }

    /* Footer */
    footer {
      margin-top: 4rem;
      padding: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #222;
    }

    /* Fade In Animation */
    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Loading spinner */
    .spinner {
      display: none;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 768px) {
      .hero h2 {
        font-size: 2rem;
      }

      .nav {
        flex-direction: column;
        align-items: flex-start;
      }

      .nav .nav-links {
        margin-top: 0.5rem;
      }
    }
  </style>
</head>
<body>

  <!-- Header -->
  <header>
    <div class="nav">
      <h1>Quick Merge</h1>
      <div class="nav-links">
        <a href="#tools">Tools</a>
        <a href="#privacy">Privacy</a>
      </div>
    </div>
  </header>

  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <h2>Merge, Compress & Convert Files Instantly</h2>
      <p>All tools run locally in your browser — fast, private, and secure.</p>
      <div class="cta">
        <button onclick="document.getElementById('tools').scrollIntoView({ behavior: 'smooth' })">Explore Tools</button>
      </div>
    </div>
  </section>

  <!-- Tools -->
  <section id="tools" class="container">
    <div class="tools">
      <!-- Merge PDF -->
      <div class="tool-card fade-in" id="merge-pdf-card">
        <h3>Merge PDF</h3>
        <p>Combine multiple PDF files into one seamless document.</p>
        <button class="tool-btn" onclick="toggleTool('merge-pdf')">Use Tool</button>
        <div class="tool-content" id="merge-pdf">
          <div class="file-input">
            <label>Select PDF files to merge:</label>
            <div class="drag-drop-area" id="merge-pdf-drop-area">
              <p>Drag & drop PDF files here</p>
              <p class="small">or click to browse</p>
            </div>
            <input type="file" id="merge-pdf-files" accept=".pdf" multiple>
            <div class="file-list" id="merge-pdf-file-list"></div>
          </div>
          <button class="tool-btn" id="merge-pdf-btn" onclick="mergePDFs()">Merge PDFs</button>
          <div class="spinner" id="merge-pdf-spinner"></div>
          <div class="status-message" id="merge-pdf-status"></div>
        </div>
      </div>

      <!-- Split PDF -->
      <div class="tool-card fade-in" id="split-pdf-card">
        <h3>Split PDF</h3>
        <p>Extract selected pages or split PDF into multiple parts.</p>
        <button class="tool-btn" onclick="toggleTool('split-pdf')">Use Tool</button>
        <div class="tool-content" id="split-pdf">
          <div class="file-input">
            <label>Select PDF file to split:</label>
            <div class="drag-drop-area" id="split-pdf-drop-area">
              <p>Drag & drop a PDF file here</p>
              <p class="small">or click to browse</p>
            </div>
            <input type="file" id="split-pdf-file" accept=".pdf">
            <div class="file-list" id="split-pdf-file-list"></div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="split-pages">Pages to extract (e.g., 1-3,5,7-9):</label>
              <input type="text" id="split-pages" placeholder="1-3,5,7-9">
            </div>
          </div>
          <button class="tool-btn" id="split-pdf-btn" onclick="splitPDF()">Split PDF</button>
          <div class="spinner" id="split-pdf-spinner"></div>
          <div class="status-message" id="split-pdf-status"></div>
        </div>
      </div>

      <!-- Compress PDF -->
      <div class="tool-card fade-in" id="compress-pdf-card">
        <h3>Compress PDF</h3>
        <p>Reduce PDF file size without losing quality or formatting.</p>
        <button class="tool-btn" onclick="toggleTool('compress-pdf')">Use Tool</button>
        <div class="tool-content" id="compress-pdf">
          <div class="file-input">
            <label>Select PDF file to compress:</label>
            <div class="drag-drop-area" id="compress-pdf-drop-area">
              <p>Drag & drop a PDF file here</p>
              <p class="small">or click to browse</p>
            </div>
            <input type="file" id="compress-pdf-file" accept=".pdf">
            <div class="file-list" id="compress-pdf-file-list"></div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="compression-level">Compression level:</label>
              <select id="compression-level">
                <option value="low">Low (better quality)</option>
                <option value="medium" selected>Medium (balanced)</option>
                <option value="high">High (smaller file)</option>
              </select>
            </div>
          </div>
          <button class="tool-btn" id="compress-pdf-btn" onclick="compressPDF()">Compress PDF</button>
          <div class="spinner" id="compress-pdf-spinner"></div>
          <div class="status-message" id="compress-pdf-status"></div>
        </div>
      </div>

      <!-- Compress Images -->
      <div class="tool-card fade-in" id="compress-image-card">
        <h3>Compress Images</h3>
        <p>Smartly compress JPEG, PNG, or WebP images with no quality loss.</p>
        <button class="tool-btn" onclick="toggleTool('compress-image')">Use Tool</button>
        <div class="tool-content" id="compress-image">
          <div class="file-input">
            <label>Select image(s) to compress:</label>
            <div class="drag-drop-area" id="compress-image-drop-area">
              <p>Drag & drop images here</p>
              <p class="small">or click to browse</p>
            </div>
            <input type="file" id="compress-image-file" accept="image/*" multiple>
            <div class="file-list" id="compress-image-file-list"></div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="image-quality">Quality (0-100):</label>
              <input type="range" id="image-quality" min="0" max="100" value="80">
              <span id="quality-value">80%</span>
            </div>
          </div>
          <button class="tool-btn" id="compress-image-btn" onclick="compressImages()">Compress Images</button>
          <div class="preview-container" id="image-preview"></div>
          <div class="spinner" id="compress-image-spinner"></div>
          <div class="status-message" id="compress-image-status"></div>
        </div>
      </div>

      <!-- Image to PDF -->
      <div class="tool-card fade-in" id="image-to-pdf-card">
        <h3>Image to PDF</h3>
        <p>Convert one or more images into a high-quality PDF document.</p>
        <button class="tool-btn" onclick="toggleTool('image-to-pdf')">Use Tool</button>
        <div class="tool-content" id="image-to-pdf">
          <div class="file-input">
            <label>Select image(s) to convert:</label>
            <div class="drag-drop-area" id="image-to-pdf-drop-area">
              <p>Drag & drop images here</p>
              <p class="small">or click to browse</p>
            </div>
            <input type="file" id="image-to-pdf-files" accept="image/*" multiple>
            <div class="file-list" id="image-to-pdf-file-list"></div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="pdf-page-size">Page size:</label>
              <select id="pdf-page-size">
                <option value="A4">A4 (210 × 297 mm)</option>
                <option value="Letter">Letter (8.5 × 11 in)</option>
                <option value="Fit">Fit to image size</option>
              </select>
            </div>
            <div class="option-group">
              <label for="pdf-orientation">Orientation:</label>
              <select id="pdf-orientation">
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
                <option value="auto">Auto (based on image)</option>
              </select>
            </div>
            <div class="option-group">
              <label for="pdf-margin">Margin (mm):</label>
              <input type="number" id="pdf-margin" min="0" max="50" value="10">
            </div>
          </div>
          <button class="tool-btn" id="image-to-pdf-btn" onclick="convertImagesToPDF()">Convert to PDF</button>
          <div class="preview-container" id="image-to-pdf-preview"></div>
          <div class="spinner" id="image-to-pdf-spinner"></div>
          <div class="status-message" id="image-to-pdf-status"></div>
        </div>
      </div>

      <!-- QR Code Generator -->
      <div class="tool-card fade-in" id="qr-code-card">
        <h3>QR Code Generator</h3>
        <p>Create stylish QR codes from any link, text, or contact info.</p>
        <button class="tool-btn" onclick="toggleTool('qr-code')">Use Tool</button>
        <div class="tool-content" id="qr-code">
          <div class="options">
            <div class="option-group">
              <label for="qr-content">QR Code Content:</label>
              <input type="text" id="qr-content" placeholder="https://example.com">
            </div>
            <div class="option-group">
              <label for="qr-color">Color:</label>
              <input type="color" id="qr-color" value="#000000">
            </div>
            <div class="option-group">
              <label for="qr-bg-color">Background Color:</label>
              <input type="color" id="qr-bg-color" value="#ffffff">
            </div>
            <div class="option-group">
              <label for="qr-size">Size (px):</label>
              <input type="number" id="qr-size" min="100" max="1000" value="200">
            </div>
          </div>
          <button class="tool-btn" id="generate-qr-btn" onclick="generateQRCode()">Generate QR Code</button>
          <div class="qr-code-container" id="qr-code-container"></div>
          <button class="tool-btn secondary" id="download-qr-btn" style="display:none;" onclick="downloadQRCode()">Download QR Code</button>
          <div class="status-message" id="qr-code-status"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- Privacy Section -->
  <section class="privacy container" id="privacy">
    <h2>Your Privacy, Respected</h2>
    <p>All files are processed directly in your browser. Nothing is ever uploaded — secure, offline, and private.</p>
  </section>

  <!-- Footer -->
  <footer>
    © 2025 Quick Merge – All rights reserved. Built with care and privacy in mind.
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize all tool sections
      setupDragAndDrop('merge-pdf', true);
      setupDragAndDrop('split-pdf', false);
      setupDragAndDrop('compress-pdf', false);
      setupDragAndDrop('compress-image', true);
      setupDragAndDrop('image-to-pdf', true);
      
      // Set up fade-in animations
      setupAnimations();
      
      // Setup quality slider
      const qualitySlider = document.getElementById('image-quality');
      const qualityValue = document.getElementById('quality-value');
      if (qualitySlider && qualityValue) {
        qualitySlider.addEventListener('input', function() {
          qualityValue.textContent = this.value + '%';
        });
      }
    });

    function setupDragAndDrop(toolId, allowMultiple) {
      const dropArea = document.getElementById(`${toolId}-drop-area`);
      const fileInput = document.getElementById(`${toolId}-${toolId.includes('image') ? 'file' : toolId.includes('merge') ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      const actionBtn = document.getElementById(`${toolId}-btn`);

      if (!dropArea || !fileInput) {
        console.error(`Elements not found for tool: ${toolId}`);
        return;
      }

      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });

      // Handle dropped files
      dropArea.addEventListener('drop', function(e) {
        handleDrop(e, fileInput, fileList, actionBtn, allowMultiple);
      }, false);
      
      // Handle click to browse files
      dropArea.addEventListener('click', function() {
        fileInput.value = null; // Reset to allow selecting same file again
        fileInput.multiple = allowMultiple;
        fileInput.click();
      });

      // Handle file selection via input
      fileInput.addEventListener('change', function(e) {
        handleFiles(e.target.files, fileList, actionBtn);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      function highlight() {
        dropArea.classList.add('active');
      }

      function unhighlight() {
        dropArea.classList.remove('active');
      }
    }

    function handleDrop(e, fileInput, fileList, actionBtn, allowMultiple) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (allowMultiple || files.length === 1) {
        // Update the file input with the dropped files
        fileInput.files = files;
        handleFiles(files, fileList, actionBtn);
      } else {
        alert('Please select only one file for this tool.');
      }
    }

    function handleFiles(files, fileListElement, actionBtn) {
      if (!files || files.length === 0) return;
      
      fileListElement.innerHTML = '';
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const fileNameSpan = document.createElement('span');
        fileNameSpan.className = 'file-item-name';
        fileNameSpan.textContent = file.name;
        
        const fileSizeSpan = document.createElement('span');
        fileSizeSpan.className = 'file-item-size';
        fileSizeSpan.textContent = formatFileSize(file.size);
        
        const removeSpan = document.createElement('span');
        removeSpan.className = 'file-item-remove';
        removeSpan.innerHTML = '&times;';
        removeSpan.addEventListener('click', function(e) {
          e.stopPropagation();
          fileItem.remove();
          // If no files left, disable the action button
          if (fileListElement.children.length === 0 && actionBtn) {
            actionBtn.disabled = true;
          }
        });
        
        fileItem.appendChild(fileNameSpan);
        fileItem.appendChild(fileSizeSpan);
        fileItem.appendChild(removeSpan);
        
        fileListElement.appendChild(fileItem);
      }
      
      // Enable the action button if files are selected
      if (actionBtn) {
        actionBtn.disabled = false;
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function toggleTool(toolId) {
      const toolCard = document.getElementById(`${toolId}-card`);
      const toolContent = document.getElementById(toolId);
      
      if (toolCard.classList.contains('active')) {
        toolCard.classList.remove('active');
        toolContent.style.display = 'none';
      } else {
        // Close all other tools first
        document.querySelectorAll('.tool-card.active').forEach(card => {
          card.classList.remove('active');
          card.querySelector('.tool-content').style.display = 'none';
        });
        
        toolCard.classList.add('active');
        toolContent.style.display = 'block';
      }
    }

    function setupAnimations() {
      const fadeElements = document.querySelectorAll('.fade-in');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1 });
      
      fadeElements.forEach(element => {
        observer.observe(element);
      });
    }

    function resetTool(toolId) {
      // Clear file inputs and lists
      const fileInput = document.getElementById(`${toolId}-${toolId.includes('image') ? 'file' : toolId.includes('merge') ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      
      if (fileInput) fileInput.value = '';
      if (fileList) fileList.innerHTML = '';
      
      // Disable action button
      const actionBtn = document.getElementById(`${toolId}-btn`);
      if (actionBtn) actionBtn.disabled = true;
      
      // Clear status messages
      const statusElement = document.getElementById(`${toolId}-status`);
      if (statusElement) {
        statusElement.textContent = '';
        statusElement.className = 'status-message';
      }
      
      // Hide spinner
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
      
      // For QR code tool, hide download button
      if (toolId === 'qr-code') {
        document.getElementById('download-qr-btn').style.display = 'none';
      }
    }

    // PDF Processing Functions
    async function mergePDFs() {
      const fileInput = document.getElementById('merge-pdf-files');
      if (!fileInput.files || fileInput.files.length < 2) {
        showStatus('merge-pdf', 'Please select at least 2 PDF files to merge', 'error');
        return;
      }

      showStatus('merge-pdf', 'Merging PDFs...', 'processing');
      
      try {
        const { PDFDocument } = PDFLib;
        const mergedPdf = await PDFDocument.create();
        
        // Process each file
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          const fileBuffer = await file.arrayBuffer();
          const pdfDoc = await PDFDocument.load(fileBuffer);
          
          // Copy pages
          const pages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
          pages.forEach(page => mergedPdf.addPage(page));
        }
        
        // Save merged PDF
        const mergedPdfBytes = await mergedPdf.save();
        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'merged-document.pdf');
        showStatus('merge-pdf', 'PDFs merged successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('merge-pdf'), 2000);
      } catch (error) {
        console.error('Error merging PDFs:', error);
        showStatus('merge-pdf', 'Error merging PDFs: ' + error.message, 'error');
      } finally {
        hideSpinner('merge-pdf');
      }
    }

    async function splitPDF() {
      const fileInput = document.getElementById('split-pdf-file');
      const pagesInput = document.getElementById('split-pages');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('split-pdf', 'Please select a PDF file to split', 'error');
        return;
      }
      
      if (!pagesInput.value.trim()) {
        showStatus('split-pdf', 'Please specify pages to extract', 'error');
        return;
      }

      showStatus('split-pdf', 'Splitting PDF...', 'processing');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Parse page ranges
        const pageRanges = parsePageRanges(pagesInput.value, pdfDoc.getPageCount());
        if (pageRanges.length === 0) {
          showStatus('split-pdf', 'Invalid page range specified', 'error');
          return;
        }
        
        // Create new PDF with selected pages
        const newPdf = await PDFDocument.create();
        for (const pageNum of pageRanges) {
          const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
          newPdf.addPage(copiedPage);
        }
        
        // Save split PDF
        const splitPdfBytes = await newPdf.save();
        const blob = new Blob([splitPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'split-document.pdf');
        showStatus('split-pdf', 'PDF split successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('split-pdf'), 2000);
      } catch (error) {
        console.error('Error splitting PDF:', error);
        showStatus('split-pdf', 'Error splitting PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('split-pdf');
      }
    }

    function parsePageRanges(rangeStr, maxPages) {
      const ranges = rangeStr.split(',');
      const pages = new Set();
      
      for (const range of ranges) {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          const validStart = Math.max(1, Math.min(start || 1, maxPages));
          const validEnd = Math.max(1, Math.min(end || maxPages, maxPages));
          
          for (let i = validStart; i <= validEnd; i++) {
            pages.add(i);
          }
        } else if (range.trim()) {
          const page = Number(range);
          if (page >= 1 && page <= maxPages) {
            pages.add(page);
          }
        }
      }
      
      return Array.from(pages).sort((a, b) => a - b);
    }

    async function compressPDF() {
      const fileInput = document.getElementById('compress-pdf-file');
      const compressionLevel = document.getElementById('compression-level').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-pdf', 'Please select a PDF file to compress', 'error');
        return;
      }

      showStatus('compress-pdf', 'Compressing PDF...', 'processing');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Set compression based on level
        const options = {
          useObjectStreams: true,
          // Add more compression options as needed
        };
        
        // Save compressed PDF
        const compressedPdfBytes = await pdfDoc.save(options);
        const blob = new Blob([compressedPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'compressed-document.pdf');
        showStatus('compress-pdf', 'PDF compressed successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('compress-pdf'), 2000);
      } catch (error) {
        console.error('Error compressing PDF:', error);
        showStatus('compress-pdf', 'Error compressing PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-pdf');
      }
    }

    async function compressImages() {
      const fileInput = document.getElementById('compress-image-file');
      const quality = document.getElementById('image-quality').value / 100;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-image', 'Please select at least one image to compress', 'error');
        return;
      }

      showStatus('compress-image', 'Compressing images...', 'processing');
      
      try {
        // Load JSZip dynamically if not available
        if (typeof JSZip === 'undefined') {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
        }

        const zip = new JSZip();
        let imgCount = 0;

        // Process each image with better compression
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;

          // Improved compression using canvas
          const compressedBlob = await compressImageFile(file, quality);
          
          if (compressedBlob) {
            zip.file(`compressed_${file.name}`, compressedBlob);
            imgCount++;
          }
        }

        if (imgCount === 0) {
          showStatus('compress-image', 'No valid images found', 'error');
          return;
        }

        // Generate ZIP with better compression
        const zipContent = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        saveAs(zipContent, 'compressed_images.zip');
        showStatus('compress-image', `${imgCount} images compressed successfully!`, 'success');
        
        setTimeout(() => resetTool('compress-image'), 2000);
      } catch (error) {
        console.error('Error compressing images:', error);
        showStatus('compress-image', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-image');
      }
    }

    // Helper function for better image compression
    async function compressImageFile(file, quality) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Maintain original dimensions or resize if needed
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // Convert to Blob with quality control
            canvas.toBlob((blob) => {
              resolve(blob);
            }, file.type, quality);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    // Dynamically load JS if missing
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function convertImagesToPDF() {
      const fileInput = document.getElementById('image-to-pdf-files');
      const pageSize = document.getElementById('pdf-page-size').value;
      const orientation = document.getElementById('pdf-orientation').value;
      const margin = Number(document.getElementById('pdf-margin').value);
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('image-to-pdf', 'Please select at least one image to convert', 'error');
        return;
      }

      showStatus('image-to-pdf', 'Converting images to PDF...', 'processing');
      
      try {
        const { PDFDocument, rgb } = PDFLib;
        const pdfDoc = await PDFDocument.create();
        
        // Process each image
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;
          
          // Add a new page for each image
          let page;
          const img = await pdfDoc.embedPng(await file.arrayBuffer());
          
          if (pageSize === 'Fit') {
            // Fit to image dimensions
            page = pdfDoc.addPage([img.width, img.height]);
            page.drawImage(img, {
              x: 0,
              y: 0,
              width: img.width,
              height: img.height,
            });
          } else {
            // Standard page sizes
            let width, height;
            if (pageSize === 'A4') {
              width = 595.28; // A4 width in points (210mm)
              height = 841.89; // A4 height in points (297mm)
            } else { // Letter
              width = 612; // Letter width in points (8.5in)
              height = 792; // Letter height in points (11in)
            }
            
            // Adjust for orientation
            if ((orientation === 'landscape') || 
                (orientation === 'auto' && img.width > img.height)) {
              [width, height] = [height, width];
            }
            
            // Add page with margins
            const marginPoints = margin * 2.83465; // Convert mm to points
            page = pdfDoc.addPage([width, height]);
            
            // Calculate image dimensions with margins
            const maxWidth = width - (marginPoints * 2);
            const maxHeight = height - (marginPoints * 2);
            
            // Maintain aspect ratio
            let imgWidth = img.width;
            let imgHeight = img.height;
            const ratio = Math.min(maxWidth / imgWidth, maxHeight / imgHeight);
            imgWidth *= ratio;
            imgHeight *= ratio;
            
            // Center the image
            const x = (width - imgWidth) / 2;
            const y = (height - imgHeight) / 2;
            
            page.drawImage(img, {
              x,
              y,
              width: imgWidth,
              height: imgHeight,
            });
          }
        }
        
        // Save PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'converted-images.pdf');
        showStatus('image-to-pdf', 'Images converted to PDF successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('image-to-pdf'), 2000);
      } catch (error) {
        console.error('Error converting images to PDF:', error);
        showStatus('image-to-pdf', 'Error converting images: ' + error.message, 'error');
      } finally {
        hideSpinner('image-to-pdf');
      }
    }

    function generateQRCode() {
      const container = document.getElementById('qr-code-container');
      const content = document.getElementById('qr-content').value;
      const color = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const size = document.getElementById('qr-size').value;
      
      if (!content) {
        showStatus('qr-code', 'Please enter content for the QR code', 'error');
        return;
      }
      
      container.innerHTML = '';
      new QRCode(container, {
        text: content,
        width: size,
        height: size,
        colorDark: color,
        colorLight: bgColor,
        correctLevel: QRCode.CorrectLevel.H
      });
      
      document.getElementById('download-qr-btn').style.display = 'block';
      showStatus('qr-code', 'QR code generated successfully!', 'success');
    }

    function downloadQRCode() {
      const container = document.getElementById('qr-code-container');
      const canvas = container.querySelector('canvas');
      const link = document.createElement('a');
      link.download = 'qrcode.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      // Reset tool after download
      setTimeout(() => {
        resetTool('qr-code');
        container.innerHTML = '';
      }, 2000);
    }

    // Helper functions
    function showStatus(toolId, message, type) {
      const statusElement = document.getElementById(`${toolId}-status`);
      statusElement.textContent = message;
      statusElement.className = 'status-message';
      
      if (type === 'processing') {
        document.getElementById(`${toolId}-spinner`).style.display = 'block';
      } else {
        document.getElementById(`${toolId}-spinner`).style.display = 'none';
        statusElement.classList.add(type);
      }
    }

    function hideSpinner(toolId) {
      document.getElementById(`${toolId}-spinner`).style.display = 'none';
    }
  </script>
</body>
</html>